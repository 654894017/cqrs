### 12306购票

12306主要性能问题还是出在出票和余票查询。当前示例通过CQRS架构结合聚合根在内存、事件回溯的手段来解决以上两个问题。 实现了买票、退票、站点最多可卖座位数限制、 站点间预留票(最低保留座位数，最多可卖座位数)、取消预留票功能。
选择座位ABC-DE暂未实现、增加、减少车厢暂未实现。现有的座位没有归属车厢的概念，如果要支持只需要做好座位号码段的隐射即可不会太复杂。
当前示例并不是要去实现一个12306的买票功能，12306的逻辑还会比这复杂很多。只是为了证明通过聚合根在内存、事件回溯的设计模式可以很好的处理非常复杂的业务领域问题，
同时又能够做到高性能。后话意淫一下：我觉得12306也采取这样的模式去设计库存这块，我想会颠覆他们现有的一个库存处理的架构体系，完全有别于现有的另一套架构体系风格。 带来更好的性能，简化整个业务架构，去掉Gemfire也不是不可能。

### Command端

抽象车次为聚合根。</br>
假设有某个列车K41车次有6个站点分别为1，2，3，4，5，6，总共100个座位</br>
我们可以按照一下方式进行座位划分:</br>
10002-100 表示站点1到站点2的票为100。</br>
20003-100 表示站点2到站点3的票为100。</br>
30004-100 表示站点3到站点4的票为100。</br>
40005-100 表示站点4到站点5的票为100。</br>
50006-100 表示站点5到站点6的票为100。</br>
如果用户需要购买站点1到站点3的票，首先我们需要判断1到2（10002），2到3（20003）站点的余票是否大于0，
如果大于0说明可以购票，然后分别扣减10002，10003分别减1。如果用户需要取消站点1到站点3的购买的票，只需要分别对10002，10003分别加1即可。

场景1:当卖掉了一张A到F的车票，则AF之间所有站站库存要减1； 场景2:列车中途需要增加减少车厢，或者有一节车厢不对外出售； 场景3:为了降低空座率,需要特定站站最多卖票数量，特定出发站的最多卖票数量； 场景4:
由于座位的唯一性，需要标示特定座位某站站已被卖出，并且找到满足特定条件的座位； 场景5:某特定车厢或座位只能卖给特定始发站的人群，即某特定车厢是给某个车站预留的；

### Query端

监听EventListener，消费座位数量变更事件信息更新Q端数据库。


